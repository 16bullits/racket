/* >>>> Generated by mkmark.rkt from mzmarksrc.c <<<< */

static int mark_srcloc_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Srcloc));
}

static int mark_srcloc_MARK(void *p, struct NewGC *gc) {
  Scheme_Stx_Srcloc *s = (Scheme_Stx_Srcloc *)p;
  gcMARK2(s->src, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Srcloc));
}

static int mark_srcloc_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Stx_Srcloc *s = (Scheme_Stx_Srcloc *)p;
  gcFIXUP2(s->src, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Stx_Srcloc));
}

#define mark_srcloc_IS_ATOMIC 0
#define mark_srcloc_IS_CONST_SIZE 1


static int mark_mark_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Mark));
}

static int mark_mark_MARK(void *p, struct NewGC *gc) {
  Scheme_Mark *m = (Scheme_Mark *)p;
  gcMARK2(m->bindings, gc);
  gcMARK2(m->owner_multi_mark, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Mark));
}

static int mark_mark_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Mark *m = (Scheme_Mark *)p;
  gcFIXUP2(m->bindings, gc);
  gcFIXUP2(m->owner_multi_mark, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Mark));
}

#define mark_mark_IS_ATOMIC 0
#define mark_mark_IS_CONST_SIZE 1


static int mark_mark_table_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Mark_Table));
}

static int mark_mark_table_MARK(void *p, struct NewGC *gc) {
  Scheme_Mark_Table *m = (Scheme_Mark_Table *)p;
  gcMARK2(m->single_marks, gc);
  gcMARK2(m->tentative_marks, gc);
  gcMARK2(m->multi_marks, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Mark_Table));
}

static int mark_mark_table_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Mark_Table *m = (Scheme_Mark_Table *)p;
  gcFIXUP2(m->single_marks, gc);
  gcFIXUP2(m->tentative_marks, gc);
  gcFIXUP2(m->multi_marks, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Mark_Table));
}

#define mark_mark_table_IS_ATOMIC 0
#define mark_mark_table_IS_CONST_SIZE 1


static int mark_propagate_table_SIZE(void *p, struct NewGC *gc) {
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Propagate_Table));
}

static int mark_propagate_table_MARK(void *p, struct NewGC *gc) {
  Scheme_Propagate_Table *m = (Scheme_Propagate_Table *)p;
  mark_mark_table_MARK(&m->mt, gc);
  gcMARK2(m->prev, gc);
  gcMARK2(m->phase_shift, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Propagate_Table));
}

static int mark_propagate_table_FIXUP(void *p, struct NewGC *gc) {
  Scheme_Propagate_Table *m = (Scheme_Propagate_Table *)p;
  mark_mark_table_FIXUP(&m->mt, gc);
  gcFIXUP2(m->prev, gc);
  gcFIXUP2(m->phase_shift, gc);
  return
  gcBYTES_TO_WORDS(sizeof(Scheme_Propagate_Table));
}

#define mark_propagate_table_IS_ATOMIC 0
#define mark_propagate_table_IS_CONST_SIZE 1


